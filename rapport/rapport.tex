\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{eurosym}
\usepackage{listings}
\usepackage{color}

\author{Anthony \textsc{Caccia} \and Romain \textsc{Fontaine} \and Nikita \textsc{Marchant} }
\date{}
\title{\textsc{INFO-F-309 : Administration Système} Projet : Rapport d'implémentation}

\setlength{\parindent}{1.5em}
\setlength{\parskip}{1em}
% \renewcommand{\baselinestretch}{1.5}

\lstset{%
    inputencoding=utf8,
    extendedchars=true,
    commentstyle=\color{red},
    keywordstyle=\color{blue},
    literate=%
            {é}{{\'{e}}}1
            {è}{{\`{e}}}1
            {ê}{{\^{e}}}1
            {ë}{{\¨{e}}}1
            {û}{{\^{u}}}1
            {ù}{{\`{u}}}1
            {â}{{\^{a}}}1
            {à}{{\`{a}}}1
            {î}{{\^{i}}}1
            {ô}{{\^{o}}}1
            {ç}{{\c{c}}}1
            {Ç}{{\c{C}}}1
            {É}{{\'{E}}}1
            {Ê}{{\^{E}}}1
            {À}{{\`{A}}}1
            {Â}{{\^{A}}}1
            {Î}{{\^{I}}}1
}
\begin{document}
\maketitle

\section{Introduction}
\label{sec:Introduction}

Le but de ce projet est de permettre à nos clients la compilation en ligne de documents rédigés au format \LaTeX sur un serveur distant.

Pour cela, une interface web sera mise en place afin de téléverser une archive contenant les sources du document à compiler. Puis, à la réception de ce document, le serveur enverra les sources dans une BSDJail afin qu'elles soient traitées sans posssibilité de compromission de celui-ci.



\section{Serveur web (Machine Debian)}
\subsection{Services}
\begin{itemize}
    \item nginx \texttt{systemctl start/stop/status nginx.service}
    \item postgresql \texttt{systemctl start/stop/status nginx.service}
    \item redis \texttt{systemctl start/stop/status redis-server.service}
\end{itemize}

\subsection{Procédure d'installation}


\section{Serveur de compilation (Machine BSD)}
\subsection{Services}
\begin{itemize}
    \item clamAV :
        \begin{itemize}
            \item clamd \texttt{/usr/local/etc/rc.d/clamav-clamd start/stop}
            \item freshclam \texttt{/usr/local/etc/rc.d/clamav-freshclam ? start/stop}
        \end{itemize}
\end{itemize}

\subsection{Procédure d'installation}

\begin{lstlisting}[language=bash]
En tant que root :
    pkg update
    pkg install bash zsh mosh git nginx python34 vim subversion screen
    pkg install cpdup py34-sqlite3 py27-psycopg2 clamav
    freebsd-update fetch
    freebsd-update install

Configuration du nfs :
    # ajouter `nfs_client_enable="YES"' dans /etc/rc.conf
    service nfsclient start # démarer le service sans devoir rebooter
    # ajouter la ligne suivante à /etc/fstab (l'ip est celle de la machine
    # debian qui est le serveur nfs)
    # 192.81.220.4:/var/nfs        /mnt        nfs        rw        0        0
    mount -a # monte le nfs

Configuration de NTP :
    # ajouter `ntpd_enable="YES"' dans /etc/rc.conf
    service ntpd start

Configuration de Celery :
En root:
    adduser # commande interactive
    # répondre comme ceci :
    # Username: celery
    # Full name: celery
    # Shell (sh csh tcsh zsh rzsh git-shell bash rbash nologin) [sh]:  bash
    # Use password-based authentication? [yes]: no

    sudo python3.4 -m ensurepip # installe pip pour python3.4
    sudo python3.4 -m pip install virtualenv # install virtualenv

    # création des dossiers pour les pid et les logs de celery
    sudo mkdir /var/log/celery
    sudo chown celery:celery /var/log/celery/
    sudo mkdir /var/run/celery
    sudo chown celery:celery /var/run/celery/

En tant que celery :
    cd # retourner dans la home de celery

    git clone https://github.com/C4ptainCrunch/info-f-309.git
    cd info-f-309/webview

    virtualenv ve
    source ve/bin/activate
    pip install -r requirements.txt
    pip install psycopg2

    nano webview/local_settings.py # y placer le contenu de
                                   # local_settings_bsd.py ci-joint

A nouveau en root :
    nano /etc/rc.d/celery #y placer le contenu de celery-rc.d ci-joint
    # ajouter `celery_enable="YES"' dans /etc/rc.conf
    # ajouter `celery_cmd="/home/celery/info-f-309/webview/ve/bin/celery"'
    # dans /etc/rc.conf
    service celery start

Vous pouvez vérifier que celery tourne bien en allant regarder son pid
dans \texttt{/var/run/celery/celery.pid}

Configuration de ClamAV:
En root :
    service clamav-freshclam onestart # démarage à la main de freshclam pour télécharger
                                      # la base de signatures
    sleep 300 # attendre quelques minutes qu'elle soit téléchargée
    service clamav-clamd onestart # démarer le daemon à la main et vérifier qu'il
                                  # accepte de lire la base de signatures
    # ajouter `clamav_freshclam_enable="YES"' et `clamav_clamd_enable="YES"'
    # dans /etc/rc.conf

Création d'un modèle pour les jails:
En root:
    # il faut d'abord construire un espace utilisateur, qui nous servira à
    # générer les jails.
    freebsd-update fetch && freebsd-update install # mise à jour des sources
    cd /usr/src
    chflags -R noschg /usr/obj  # pour effacer les
    rm -rf /usr/obj             # anciens build
    make buildworld # environ 2 - 3 heures

    # on peut ensuite générer le modèle pour les jails :
    #    - une partie en lecture seule sera dans /home/j/mroot
    #    - une partie en lecture écriture sera dans /home/j/skel
    mkdir -p /home/j/mroot /home/j/skel /home/js
    make installworld DESTDIR=/home/j/mroot
    make distribution DESTDIR=/home/j/mroot
    chroot /home/j/mroot   # installation des logiciels nécessaires
      tzsetup
      pkg update && pkg install texlive-full
      exit
    # on va déplacer les dossiers qui seront en rw dans skel
    mv /home/j/mroot/etc /home/j/skel
    mv /home/j/mroot/root /home/j/skel
    mv /home/j/mroot/tmp /home/j/skel
    mv /home/j/mroot/home /home/j/skel
    # et on va symlinker ces dossiers vers "la racine" mroot
    cd /home/j/mroot
    mkdir s # l'endroit ou sera monté le système rw
    ln -s s/etc etc
    ln -s s/root root
    ln -s s/home home
    ln -s s/tmp tmp

Création d'une jail temporaire:
En root:
    # pour créer une jail nommée 'example'
    mkdir /home/j/example
    cpdup /home/j/skel /home/js/example
    mount_nullfs -o ro /home/j/mroot /home/j/example
    mount_nullfs -o rw /home/js/example /home/j/example/s
    mount -t devfs /dev /home/j/example/dev
    # 'jail -c' crée une nouvelle jail, on lui passe le chemin vers la
    # racine de la jail, on peut lui passer un nom afin de pouvoir
    # lui envoyer des commandes facilement (l'alternative étant d'utiliser
    # son jid (jail id) et on passe l'option persist afin que celle-ci
    # reste active même lorsqu'elle n'exécute aucune action)
    jail -c path=/home/j/example name=example persist
    # on peut constater sa création en utilisant la commande jls, qui liste
    # les jails actives

Utilisation de la jail temporaire:
En root:
    # on peut ajouter des fichiers dans la jail depuis le système hote
    # simplement en les copiant vers le chemin de cette jail
    touch /home/js/example/home/example.txt
    # pour faire exécuter une action à la jail, on utilise la commande
    # jexec, avec le nom ou le jid de la jail et la commande à utiliser
    jexec example sh -c 'cd /home && ls'
    # la commande ci-dessus devrait afficher le fichier example.txt

Suppression d'une jail temporaire:
En root:
    # il suffit de stopper cette jail, démonter les systèmes de fichiers
    # et supprimer les dossiers correspondants
    jail -r example
    umount /home/j/example/s
    umount /home/j/example/dev
    umount /home/j/example
    chflags -R noschg /home/j/example
    chflags -R noschg /home/js/example
    rm -rf /home/j/example
    rm -rf /home/js/example

\end{lstlisting}


\end{document}
