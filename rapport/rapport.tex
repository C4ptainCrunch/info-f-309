\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{eurosym}
\usepackage{listings}
\usepackage{color}
\usepackage[titletoc,toc,title]{appendix}

\author{Anthony \textsc{Caccia} \and Romain \textsc{Fontaine} \and Nikita \textsc{Marchant} }
\date{}
\title{\textsc{INFO-F-309 : Administration Système} Projet : Rapport d'implémentation}

\setlength{\parindent}{1.5em}
\setlength{\parskip}{1em}
% \renewcommand{\baselinestretch}{1.5}

\lstset{%
    inputencoding=utf8,
    extendedchars=true,
    commentstyle=\color{red},
    keywordstyle=\color{blue},
    literate=%
            {é}{{\'{e}}}1
            {è}{{\`{e}}}1
            {ê}{{\^{e}}}1
            {ë}{{\¨{e}}}1
            {û}{{\^{u}}}1
            {ù}{{\`{u}}}1
            {â}{{\^{a}}}1
            {à}{{\`{a}}}1
            {î}{{\^{i}}}1
            {ô}{{\^{o}}}1
            {ç}{{\c{c}}}1
            {Ç}{{\c{C}}}1
            {É}{{\'{E}}}1
            {Ê}{{\^{E}}}1
            {À}{{\`{A}}}1
            {Â}{{\^{A}}}1
            {Î}{{\^{I}}}1
}
\begin{document}
\maketitle

\tableofcontents
\newpage

\section{Introduction}
\label{sec:Introduction}

Le but de ce projet est de permettre à nos clients la compilation en ligne de documents rédigés au format \LaTeX sur un serveur distant.

Pour cela, une interface web sera mise en place afin de téléverser une archive contenant les sources du document à compiler.
Puis, à la réception de ce document, le serveur enverra les sources dans une BSDJail afin qu'elles soient traitées sans posssibilité de compromission de celui-ci.

\section{Machines déployées}
\label{sec:Machines déployées}

Deux machines ont été déployées: une première machine sur laquelle tourne la distribution GNU/Linux Debian, et une deuxième qui a pour système d'exploitation la distribution FreeBSD.

La première machine a pour tâche la mise en service de l'interface web,
le stockage des fichiers \texttt{zip} et \texttt{pdf}
ainsi que l'envoi des ordres de compilation sur la seconde machine.

La seconde machine reçoit les ordres de compilation, crée des BSDJails à la volée, y place les sources récupérées sur la première machine,
y lance les compilations et l'analyse antivirus et renvoie le document pdf final à la première machine.

\section{Choix effectués}
\label{sec:Choix effectués}

Le partage des fichiers entre les deux serveurs est géré par la mise en place d'un protocole NFS.

L'application web est réalisée grâce au framework Django pour Python 3.
%TODO

\section{Serveur web (Machine Debian)}
\subsection{Services}
Les services suivants tournent sur le premier serveur :

\texttt{Nginx} : il sert de proxy http pour l'application \texttt{Django} et sert via http les fichiers \texttt{zip} et \texttt{pdf}.
Il écoute sur toutes les interfaces et sur le port \texttt{80}.
Commande : \texttt{systemctl start/stop/status nginx.service}

\texttt{Postgresql} : le serveur de base de données.
Il sert une unique base de données : \texttt{webview} qui est utilisée par l'application web.
Il écoute en local sur un socket UNIX ansi que sur l'interface publique (retreinte par le firewall) sur le port \texttt{5432}.
Commande : \texttt{systemctl start/stop/status nginx.service}

\texttt{Redis} est utilisé comme message broker entre \texttt{Celery} et l'application web. Celui-ci écoute sur toutes les interfaces sur le port \texttt{6379} et demande un mot de passe.
Commande : \texttt{systemctl start/stop/status redis-server.service}

\texttt{Django} : C'est un processus \texttt{gunicorn} qui sert l'application web sur le port \texttt{8000} sur \texttt{localhost}.
Commande : \texttt{systemctl start/stop/status django.service}

Serveur \texttt{nfs} : le répertoire \texttt{/var/nfs} est partagé avec la machine BSD via \texttt{nfs}.
Dans celui-ci se trouve \texttt{/var/nfs/webview/media} dans lequel est stocké tous les fichiers media de Django (principalement les fichiers \texttt{zip} et \texttt{pdf}).

\texttt{NTP} : vu que nous travaillons sur plusieurs machines en parralèlle, il est indispensable d'avoir la même heure partout.
C'est le travail de \texttt{NTP}.
Commande : \texttt{systemctl start/stop/status ntp.service}

\texttt{iptables} : % TODO rom1


\subsection{Procédure d'installation}

\subsection{Mise à jour}

Dans le cas ou l'on voudrait mettre à jour ce serveur,
il faut exéccuter ces deux commandes en tant que root :
\texttt{apt-get update}, \texttt{apt-get upgrade}.

Pour mettre à jour l'application web, en tant que \texttt{www-data}
il faut exécuter \texttt{git pull} depuis le dossier \texttt{/var/www/info-f-309}
et ensuite en tant que \texttt{root} exécuter \texttt{systemctl restart django}.

Dans le cas ou le schéma de la base de donnée aurait changé,
il faut aussi exécuter \texttt{/var/www/info-309/webview/ve/bin/python /var/www/info-309/webview/manage.py migrate}

\section{Serveur de compilation (Machine BSD)}
\subsection{Services}

\texttt{Celery} : Celery est un ``worker'' : il écoute sur le ``message broker'' (le \texttt{redis} qui tourne sur l'autre machine) en attendant des ordres.
Dès qu'il recoit une tache, il l'exécute et renvoie le résultat au ``message broker''.
C'est \texttt{Celery} qui récupérera les fichiers sur le \texttt{nfs}, créera une \texttt{jail}, y compilera le \LaTeX, etc.
Commande : \texttt{service celery start/stop}

\texttt{ClamAV} : c'est l'outil qui nous permet de détecter des signatures de virus dans les pdf.
Celui-ci est découpé en deux daemons :
        \begin{itemize}
            \item \texttt{clamd} : le processus qui vérifie les fichiers.

            Il est accessible depuis \texttt{unix://var/run/clamav/clamd.sock}

            (Commande : \texttt{/usr/local/etc/rc.d/clamav-clamd start/stop})
            \item \texttt{freshclam} s'occupe de garder la base de signatures à jour.

            (Commande : \texttt{/usr/local/etc/rc.d/clamav-freshclam start/stop})
        \end{itemize}

\vspace{1em} % wtf latex
Client \texttt{nfs} : il se connecte à la machine \texttt{debian} et permet à \texttt{Celery} d'avoir accès aux fichiers téléversés sur l'autre machine ainsi qu'à renvoyer les fichiers compilés.
Commande : \texttt{service nfsclient start/stop} ainsi que \texttt{mount /mnt} et \texttt{umount /mnt}

\texttt{NTP} : même utilité que sur l'autre machine.
Commande : \texttt{service start/stop ntpd}

\subsection{Installation}
Pour commencer, il a fallu installer quelques paquets avec la commande \emph{pkg}:
\begin{lstlisting}[language=bash]
  pkg update
  pkg install bash zsh mosh git nginx python34 vim subversion screen
  pkg install cpdup py34-sqlite3 py27-psycopg2 clamav
\end{lstlisting}

\subsection{Contrôle des BSDJails}
\label{subs:Contrôle des BSDJails}
Afin de pouvoir créer des BSDJails, il nous faut d'abord construire un espace utilisateur de référence.
Il nous faut pour cela mettre à jour les sources FreeBSD situées dans le dossier \texttt{/usr/src}:
\begin{lstlisting}[language=bash]
  freebsd-update fetch
  freebsd-update install
\end{lstlisting}
On peut ensuite supprimer l'éventuel ancien build, en n'oubliant pas de modifier les flags des fichiers pour que ceux-ci puissent être modifiés :
\begin{lstlisting}[language=bash]
  chflags -R noschg /usr/obj
  rm -rf /usr/obj
\end{lstlisting}
Afin de minimiser la taille de ce build, il peut être construit en omettant certaines parties du filesystem. Il suffit pour cela d'éditer le fichier \texttt{/etc/src.conf}. Celui-ci est disponible en annexe \ref{sub:etc-src-conf}.
Enfin, on peut lancer la compilation de ce build, ce qui peut prendre un certain temps (plus de deux heures en général):
\begin{lstlisting}[language=bash]
  cd /usr/src
  make buidworld
\end{lstlisting}

À partir de ce build, il a été décidé de créer un modèle pour la création des jails.
Ce modèle sera en deux parties:
\begin{itemize}
  \item la première partie située dans /home/j/mroot qui contiendra la partie commune à toutes ces jails, et qui sera toujours en lecture seule,
  \item la seconde partie située dans /home/j/skel qui contiendra des dossiers propres à chaque jail et qui seront accessible en lecture-écriture.
\end{itemize}
Pour commencer, la première partie va être créée grâce à ces deux commandes:
\begin{lstlisting}[language=bash]
  cd /usr/src
  mkdir /home/j/mroot
  # crée un "sous-système" dans le dossier DESTDIR
  make installworld DESTDIR=/home/j/mroot
  # copie les fichiers de configuration dans la jail
  make distribution DESTDIR=/home/j/mroot
\end{lstlisting}
Là, le dossier dans DESTDIR contiendra un sous-système dans lequel nous pouvons installer les logiciels nécessaires aux tâches de ces jails, c'est à dire la compilation \LaTeX:
\begin{lstlisting}[language=bash]
  chroot /home/j/mroot   # installation des logiciels nécessaires
  pkg update && pkg install texlive-full
  exit
\end{lstlisting}
Ensuite, nous allons déplacer les dossiers accessibles en lecture-écriture dans la seconde partie et ajouter des liens symboliques dans le dossier /home/j/mroot/s, où sera monté celle-ci:
\begin{lstlisting}[language=bash]
  mkdir /home/j/skel
  mv /home/j/mroot/etc /home/j/skel
  mv /home/j/mroot/root /home/j/skel
  mv /home/j/mroot/tmp /home/j/skel
  mv /home/j/mroot/home /home/j/skel
  cd /home/j/mroot
  mkdir s
  ln -s s/etc etc
  ln -s s/root root
  ln -s s/home home
  ln -s s/tmp tmp
\end{lstlisting}
Nous avons dès lors notre modèle pour la création de jails.

Voici maintenant un exemple de création d'une jail, nommée example.
On commence par créer les dossiers contenant la jail, le premier simplement avec \emph{mkdir},
le deuxième avec la commande \emph{cpdup}, qui crée une exacte réplique du fichier source.
On peut ensuite les monter grâce aux commandes \emph{mount\_nullfs} et \emph{mount}.
Cette première commande permet d'accéder à des fichiers depuis différents emplacements.

\begin{lstlisting}[language=bash]
  mkdir /home/j/example
  cpdup /home/j/skel /home/js/example
  mount_nullfs -o ro /home/j/mroot /home/j/example
  mount_nullfs -o rw /home/js/example /home/j/example/s
  mount -t devfs /dev /home/j/example/dev
\end{lstlisting}
Là, on peut utiliser la commande \emph{jail} afin de lancer une jail:
\begin{lstlisting}[language=bash]
  jail -c path=/home/j/example name=example persist
\end{lstlisting}
"-c" indique que l'on crée une jail, "path" indique l'emplacement de la jail,
"name" son nom et l'option "persist" garde la jail en route même si celle-ci n'accomplit aucune action.

Afin d'accéder à cette jail depuis l'extérieur, il suffit d'accéder à l'emplacement où celle-ci se situe.
Pour lancer une commande à l'intérieur de cette jail,
on utilise la commande \emph{jexec} dont le premier argument est soit le nom de la jail,
soit son jid (qui peut être déterminé grâce à la commande \emph{jls}),
et les autres arguments correspondent à la commande à exécuter.
Par exemple, pour ajouter un fichier "test.txt" dans la jail depuis l'extérieur et le lister depuis l'intérieur:
\begin{lstlisting}[language=bash]
  touch /home/js/example/home/test.txt
  jexec example ls /home
\end{lstlisting}

Pour désactiver et supprimer cette jail, il faut tout d'abord la stopper grâce à la commande \emph{jail} à laquelle on passe le flag "-r".
Puis on démonte tous les dossiers montés et on peut enfin les supprimer.
\begin{lstlisting}[language=bash]
  jail -r example
  umount /home/j/example/s
  umount /home/j/example/dev
  umount /home/j/example
  chflags -R noschg /home/j/example
  chflags -R noschg /home/js/example
  rm -rf /home/j/example
  rm -rf /home/js/example
\end{lstlisting}

\subsection{Configuration du NFS}
\begin{enumerate}
  \item ajouter ``nfs\_client\_enable="YES"'' dans \texttt{/etc/rc.conf}
  \item démarrer le service avec \emph{service nfsclient start}
  \item ajouter la ligne ``192.81.220.4:/var/nfs        /mnt        nfs        rw        0        0'' à \texttt{/etc/fstab}
  \item remonter le sytème de fichier défini dans le fstab avec \emph{mount -a}
\end{enumerate}

\subsection{Configuration du NTP}
\begin{enumerate}
  \item ajouter ``ntpd\_enable="YES"'' dans \texttt{/etc/rc.conf}
  \item démarrer le service avec \emph{service ntpd start}
\end{enumerate}

\begin{lstlisting}[language=bash]
Configuration de Celery :
En root:
    adduser # commande interactive
    # répondre comme ceci :
    # Username: celery
    # Full name: celery
    # Shell (sh csh tcsh zsh rzsh git-shell bash rbash nologin) [sh]:  bash
    # Use password-based authentication? [yes]: no

    sudo python3.4 -m ensurepip # installe pip pour python3.4
    sudo python3.4 -m pip install virtualenv # install virtualenv

    # création des dossiers pour les pid et les logs de celery
    sudo mkdir /var/log/celery
    sudo chown celery:celery /var/log/celery/
    sudo mkdir /var/run/celery
    sudo chown celery:celery /var/run/celery/

En tant que celery :
    cd # retourner dans la home de celery

    git clone https://github.com/C4ptainCrunch/info-f-309.git
    cd info-f-309/webview

    virtualenv ve
    source ve/bin/activate
    pip install -r requirements.txt
    pip install psycopg2

    nano webview/local_settings.py # y placer le contenu de
                                   # local_settings_bsd.py ci-joint

A nouveau en root :
    nano /etc/rc.d/celery #y placer le contenu de celery-rc.d ci-joint
    # ajouter `celery_enable="YES"' dans /etc/rc.conf
    # ajouter `celery_cmd="/home/celery/info-f-309/webview/ve/bin/celery"'
    # dans /etc/rc.conf
    service celery start

Vous pouvez vérifier que celery tourne bien en allant regarder son pid
dans \texttt{/var/run/celery/celery.pid}

Configuration de ClamAV:
En root :
    # démarage à la main de freshclam pour télécharger
    # la base de signatures
    service clamav-freshclam onestart
    # attendre quelques minutes qu'elle soit téléchargée
    sleep 300
    # démarer le daemon à la main et vérifier qu'il
    # accepte de lire la base de signatures
    service clamav-clamd onestart
    # ajouter `clamav_freshclam_enable="YES"' et `clamav_clamd_enable="YES"'
    # dans /etc/rc.conf


\end{lstlisting}

\subsection{Mise à jour}

Dans le cas ou l'on voudrait mettre à jour ce serveur,
il faut exéccuter ces deux commandes en tant que root :
\texttt{freebsd-update fetch} puis \texttt{freebsd-update install}.

Pour mettre à jour les tâches \texttt{Celery},
en tant que \texttt{celery} il faut exécuter \texttt{git pull}
epuis le dossier \texttt{/home/celery/info-f-309}
et ensuite en tant que \texttt{root} exécuter \texttt{service restart celery}.

\newpage
\begin{appendices}
  \section{Fichiers de configuration}
  \subsection{/etc/src.conf}
  \label{sub:etc-src-conf}
  \lstinputlisting[basicstyle=\ttfamily]{annexe/etc-src.conf}
\end{appendices}


\end{document}
